# websocket服务器的整体架构
## 1.接收请求
wsserver的handleClient对应一个协程，也就是说一个连接建立，启动一个读协程循环不断读取数据，然后将读到的数据放到/_/pushReq这个servlet中进行处理，这个servlet需要框架实现，读取失败可直接关闭--->因为此时没必要再等写协程发送完毕，直接关闭即可

这个servlet进行框架层面的处理，同时也需要进行业务层面的处理
1. OnConnect函数首先将session放到smap中进行管理，然后在调用具体url的servlet的onconnect函数进行业务处理
2. 其次handle方法中，主要的工作是将这个请求push到logicSystem的msgqueue中，由逻辑模块处理，逻辑模块再根据具体url进行路由处理
3. onclose函数也onconnect函数相反

## 2.处理请求
方案一：
逻辑模块logicsystem
逻辑模块的作用就是进行业务处理，可以通过配置文件配置协程数量，任务的分配也是需要保证处理的顺序性，因此，任务的分配必须保证同一个session的请求放在同一个逻辑处理协程中，不能出现一个session的两个包在不同协程处理，这样就保证不了处理完成的顺序性，在同一个协程中由于队列的存在即可保证，通过将session指针进行hash后取余数即可找到一个逻辑协程，【逻辑层想进行任何主动关闭连接的逻辑，都是需要发送空包，而不是直接关闭。

方案二：
接收请求的协程直接调用servlet进行业务处理-----但是为了保证io的高并发，将业务处理逻辑转移到process调度器中，不占用io调度器的调度时间片----优先考虑这个实现方案
## 3.发送响应
发送响应是由每一个连接对应的发送协程实现的，也就是在连接建立好后，在onconnect函数中启动一个写协程，即每个连接都对应一个写协程，每个协程从该连接的发送队列中获取响应包，并同步发送到客户端，逻辑层发送响应是异步发送的，只是将响应包扔到连接的发送队列中。同时，在我看来，由于发送的逻辑是异步的，是由发送协程独立发送的，因此在逻辑层是肯定不能主动调用session的close函数的，因为close的时候其实是无法保证发送队列中的包都发送完毕，因此，当服务端这边有主动关闭连接的逻辑，只需要向发送队列中发送一个空响应，由发送协程获取后，执行关闭连接的逻辑即可，此时写协程再退出

能获取session智能指针的几个方面
1. 读协程
2. 写协程
3. smap
## 4.心跳检测逻辑
方案1:
当服务器启动后，可以启动一个定时器，这个定时器定期去smap中查看连接是否过期【看session的上次使用时间即可】，如果过期了，这个定时器协程的逻辑就是：
1. 肯定要通知客户端由于长时间未操作下线---->发送一个结束包
2. 服务器主动关闭连接---->由于还是逻辑层，因此发送空响应给session的发送队列
3. 进行一些业务处理
这样，对应发送协程，首先通知下线，然后迅速关闭连接

方案2:
每个session内部加一个成员timer，连接建立后启动定时器ns后触发，这个触发函数发送空包，然后通过协程信号量然后等待写协程退出，将连接从map中除去。并且，在每次收到数据后，没超时则将timer取消，然后再重新设置一次，这样循环往复
# 5.连接管理
server中使用一个container管理所有的连接----封装一个容器，并提供各种操作接口